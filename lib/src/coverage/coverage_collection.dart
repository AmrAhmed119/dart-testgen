import 'dart:async';
import 'dart:io';

import 'package:coverage/coverage.dart';
import 'package:package_config/package_config.dart';
import 'package:path/path.dart' as path;
import 'package:stack_trace/stack_trace.dart';
import 'package:testgen/src/analyzer/declaration.dart';
import 'package:testgen/src/coverage/util.dart';

typedef CoverageData = List<(String, List<int>)>;

final _allProcesses = <Process>[];
bool _isSignalsWatched = false;

Future<void> _dartRun(
  List<String> args, {
  required String packageAbsolutePath,
  required void Function(String) onStdout,
  required void Function(String) onStderr,
}) async {
  final process = await Process.start(
    Platform.executable,
    args,
    workingDirectory: packageAbsolutePath,
  );
  _allProcesses.add(process);

  void listen(
    Stream<List<int>> stream,
    IOSink sink,
    void Function(String) onLine,
  ) {
    final broadStream = stream.asBroadcastStream();
    broadStream.listen(sink.add);
    broadStream.lines().listen(onLine);
  }

  listen(process.stdout, stdout, onStdout);
  listen(process.stderr, stderr, onStderr);

  final result = await process.exitCode;

  // Don't throw an error if the process exits with code 79 which is
  // common for no tests found.
  if (result != 0 && result != 79) {
    throw ProcessException(Platform.executable, args, '', result);
  }
}

void _killSubprocessesAndExit(ProcessSignal signal) {
  for (final process in _allProcesses) {
    process.kill(signal);
  }
  exit(1);
}

void _watchExitSignal(ProcessSignal signal) {
  signal.watch().listen(_killSubprocessesAndExit);
}

/// Runs Dart tests in the specified [packageDir] and collects coverage data.
///
/// This function starts a Dart test process with the appropriate
/// [vmServicePort] and coverage flags [branchCoverage] and [functionCoverage],
/// waits for the VM service URI to become available, and then collects coverage
/// data from all isolates in the running Dart VM.
///
/// [scopeOutput] Restrict coverage to files with these path prefixes.
///
/// The collected coverage data is returned as a map of coverage information.
Future<Map<String, dynamic>> runTestsAndCollectCoverage(
  String packageDir, {
  String vmServicePort = '0',
  bool branchCoverage = false,
  bool functionCoverage = false,
  required Set<String> scopeOutput,
}) async {
  print('[Coverage] Running tests and collecting coverage...');
  if (!_isSignalsWatched) {
    _watchExitSignal(ProcessSignal.sighup);
    _watchExitSignal(ProcessSignal.sigint);
    if (!Platform.isWindows) {
      _watchExitSignal(ProcessSignal.sigterm);
    }
    _isSignalsWatched = true;
  }

  _addFileImports(packageDir);

  final serviceUriCompleter = Completer<Uri>();
  final testProcess = _dartRun(
    [
      if (branchCoverage) '--branch-coverage',
      'run',
      '--pause-isolates-on-exit',
      '--disable-service-auth-codes',
      '--enable-vm-service=$vmServicePort',
      'test',
    ],
    packageAbsolutePath: packageDir,
    onStdout: (line) {
      if (!serviceUriCompleter.isCompleted) {
        final uri = extractVMServiceUri(line);
        if (uri != null) {
          serviceUriCompleter.complete(uri);
        }
      }
    },
    onStderr: (line) {
      if (!serviceUriCompleter.isCompleted) {
        if (line.contains('Could not start the VM service')) {
          _killSubprocessesAndExit(ProcessSignal.sigkill);
        }
      }
    },
  );

  final serviceUri = await serviceUriCompleter.future;

  final coverageResults = await Chain.capture(
    () async {
      return await collect(
        serviceUri,
        true,
        true,
        false,
        scopeOutput,
        branchCoverage: branchCoverage,
        functionCoverage: functionCoverage,
      );
    },
    onError: (dynamic error, Chain chain) {
      stderr.writeln(error);
      stderr.writeln(chain.terse);
      // See http://www.retro11.de/ouxr/211bsd/usr/include/sysexits.h.html
      // EX_SOFTWARE
      exit(70);
    },
  );

  await testProcess;

  return coverageResults;
}

/// Generates a Dart file that imports all Dart files in the `lib` directory.
/// This ensures the coverage tool includes these files in its analysis,
/// even if they are not directly referenced in tests.
Future<void> _addFileImports(String packagePath) async {
  final libDir = Directory(path.join(packagePath, 'lib'));
  if (!libDir.existsSync()) {
    throw ArgumentError(
      'Directory "$packagePath" does not contain a lib folder',
    );
  }

  final config = await findPackageConfig(Directory(packagePath));
  final dartFiles = libDir
      .listSync(recursive: true)
      .whereType<File>()
      .where((file) => file.path.endsWith('.dart'))
      .map((file) => 'import \'${config?.toPackageUri(file.uri)}\';')
      .join('\n');

  final importFile = File(
    path.join(packagePath, 'test', 'testgen', 'coverage_test.dart'),
  );
  importFile.createSync(recursive: true);
  importFile.writeAsStringSync('''
// This file is generated by testgen to include all files in the lib directory
// for coverage collection purposes.
$dartFiles
void main() {}
''');
}

/// Formats raw coverage results into a [CoverageData] structure.
///
/// [CoverageData] is a `List<(String, List<int>)>` where:
///   - The first element is the package path of a Dart source file.
///   - The second element is a list of line numbers in that file which were
///     not hit by any test case (i.e., lines that require additional testing).
Future<CoverageData> formatCoverage(
  Map<String, dynamic> coverageResults,
  String packageDir,
) async {
  final List<Map<String, dynamic>> coverage = coverageResults['coverage'];
  final hitmaps = await HitMap.parseJson(coverage, packagePath: packageDir);
  return hitmaps.entries
      .map(
        (fileHits) => (
          fileHits.key,
          fileHits.value.lineHits.entries
              .where((lineHit) => lineHit.value == 0)
              .map((lineHit) => lineHit.key)
              .toList(),
        ),
      )
      .where((fileHits) => fileHits.$2.isNotEmpty)
      .toList();
}

/// Evaluates whether a generated test file has successfully improved code
/// coverage for a specific declaration.
///
/// This function runs test after a new test has been generated and compares
/// the current coverage metrics against the baseline coverage metrics that were
/// recorded before test generation. It determines if the newly generated test
/// is actually hitting the previously uncovered lines.
Future<bool> validateTestCoverageImprovement({
  required Declaration declaration,
  required int baselineUncoveredLines,
  required String packageDir,
  required Set<String> scopeOutput,
}) async {
  final coverage = await runTestsAndCollectCoverage(
    packageDir,
    scopeOutput: scopeOutput,
  );
  final coverageByFile = await formatCoverage(coverage, packageDir);

  int currentUncoveredLines = 0;
  final fileCoverage =
      coverageByFile.where((pair) => pair.$1 == declaration.path).firstOrNull;

  for (final line in fileCoverage?.$2 ?? <int>[]) {
    if (line >= declaration.startLine && line <= declaration.endLine) {
      currentUncoveredLines++;
    }
  }
  print(
    '[Coverage] Validating coverage improvement for ${declaration.name}...',
  );
  print('[Coverage] Baseline uncovered lines: $baselineUncoveredLines');
  print('[Coverage] Current uncovered lines: $currentUncoveredLines');
  print(
    '[Coverage] Coverage improved: ${currentUncoveredLines < baselineUncoveredLines}',
  );

  return currentUncoveredLines < baselineUncoveredLines;
}
